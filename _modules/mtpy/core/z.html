<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mtpy.core.z &#8212; MTpy 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="MTpy 0.2 documentation" href="../../../master_index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../master_index.html">MTpy 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for mtpy.core.z</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">=============</span>
<span class="sd">z module</span>
<span class="sd">=============</span>

<span class="sd">Classes</span>
<span class="sd">---------</span>
<span class="sd">    * Z --&gt; deals with impedance tesnsor.</span>
<span class="sd">    * Tipper --&gt; deals with Tipper matrix.</span>


<span class="sd">LK, JP 2013</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># =================================================================</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">mtpy.utils.calculator</span> <span class="k">as</span> <span class="nn">MTcc</span>
<span class="kn">import</span> <span class="nn">mtpy.utils.exceptions</span> <span class="k">as</span> <span class="nn">MTex</span>


<span class="c1"># =================================================================</span>


<span class="c1"># ------------------------</span>
<div class="viewcode-block" id="Z"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Z">[docs]</a><span class="k">class</span> <span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Z class - generates an impedance tensor (Z) object.</span>

<span class="sd">    Z is a complex array of the form (n_freq, 2, 2),</span>
<span class="sd">    with indices in the following order:</span>

<span class="sd">        - Zxx: (0,0)</span>
<span class="sd">        - Zxy: (0,1)</span>
<span class="sd">        - Zyx: (1,0)</span>
<span class="sd">        - Zyy: (1,1)</span>

<span class="sd">    All errors are given as standard deviations (sqrt(VAR))</span>

<span class="sd">    Arguments</span>
<span class="sd">    ------------</span>

<span class="sd">        **z_array** : numpy.ndarray(n_freq, 2, 2)</span>
<span class="sd">                    array containing complex impedance values</span>

<span class="sd">        **z_err_array** : numpy.ndarray(n_freq, 2, 2)</span>
<span class="sd">                       array containing error values (standard deviation)</span>
<span class="sd">                       of impedance tensor elements</span>
<span class="sd">        **freq** : np.ndarray(n_freq)</span>
<span class="sd">                 array of frequency values corresponding to impedance tensor</span>
<span class="sd">                 elements.</span>

<span class="sd">    =============== ===========================================================</span>
<span class="sd">    Attributes      Description</span>
<span class="sd">    =============== ===========================================================</span>
<span class="sd">    freq             array of frequencies corresponding to elements of z</span>
<span class="sd">    rotation_angle   angle of which data is rotated by</span>
<span class="sd">    z                impedance tensor</span>
<span class="sd">    z_err             estimated errors of impedance tensor</span>
<span class="sd">    resistivity      apparent resisitivity estimated from z in Ohm-m</span>
<span class="sd">    resistivity_err  apparent resisitivity error</span>
<span class="sd">    phase            impedance phase (deg)</span>
<span class="sd">    phase_err        error in impedance phase</span>
<span class="sd">    =============== ===========================================================</span>

<span class="sd">    =================== =======================================================</span>
<span class="sd">    Methods             Description</span>
<span class="sd">    =================== =======================================================</span>
<span class="sd">    det                  calculates determinant of z with errors</span>
<span class="sd">    invariants           calculates the invariants of z</span>
<span class="sd">    inverse              calculates the inverse of z</span>
<span class="sd">    remove_distortion    removes distortion given a distortion matrix</span>
<span class="sd">    remove_ss            removes static shift by assumin Z = S * Z_0</span>
<span class="sd">    norm                 calculates the norm of Z</span>
<span class="sd">    only1d               zeros diagonal components and computes</span>
<span class="sd">                         the absolute valued mean of the off-diagonal</span>
<span class="sd">                         components.</span>
<span class="sd">    only2d               zeros diagonal components</span>
<span class="sd">    res_phase            computes resistivity and phase</span>
<span class="sd">    rotate               rotates z positive clockwise, angle assumes</span>
<span class="sd">                         North is 0.</span>
<span class="sd">    set_res_phase        recalculates z and z_err, needs attribute freq</span>
<span class="sd">    skew                 calculates the invariant skew (off diagonal trace)</span>
<span class="sd">    trace                calculates the trace of z</span>
<span class="sd">    =================== =======================================================</span>

<span class="sd">    Example</span>
<span class="sd">    -----------</span>

<span class="sd">        &gt;&gt;&gt; import mtpy.core.z as mtz</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; z_test = np.array([[0+0j, 1+1j], [-1-1j, 0+0j]])</span>
<span class="sd">        &gt;&gt;&gt; z_object = mtz.Z(z_array=z_test, freq=[1])</span>
<span class="sd">        &gt;&gt;&gt; z_object.rotate(45)</span>
<span class="sd">        &gt;&gt;&gt; z_object.resistivity</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_err_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise an instance of the Z class.</span>

<span class="sd">        Arguments</span>

<span class="sd">            **z_array** : numpy.ndarray(n_freq, 2, 2)</span>
<span class="sd">                        array containing complex impedance values</span>

<span class="sd">            **z_err_array** : numpy.ndarray(n_freq, 2, 2)</span>
<span class="sd">                           array containing error values (standard deviation)</span>
<span class="sd">                           of impedance tensor elements</span>

<span class="sd">            **freq** : np.ndarray(n_freq)</span>
<span class="sd">                     array of frequency values corresponding to impedance</span>
<span class="sd">                     tensor elements.</span>

<span class="sd">        Initialises the attributes with None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="n">z_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span> <span class="o">=</span> <span class="n">z_err_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>

        <span class="k">if</span> <span class="n">z_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">z_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_array</span>

        <span class="k">if</span> <span class="n">z_err_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z_err_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">z_err_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_err_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">)))</span>

        <span class="c1"># make attributes for resistivity and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity_err</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>

    <span class="c1"># ---frequency-------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lo_freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the array of freq.</span>

<span class="sd">        Arguments</span>
<span class="sd">                -------------</span>

<span class="sd">            **lo_freq** : list or array of frequnecies (Hz)</span>

<span class="sd">        No test for consistency!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">):</span>
            <span class="n">lo_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lo_freq</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;length of freq list/array not correct&#39;</span>
                           <span class="s1">&#39;(</span><span class="si">{0}</span><span class="s1"> instead of </span><span class="si">{1}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">),</span>
                                                         <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)))</span>
                    <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">)</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Need to input frequency array&#39;</span>

    <span class="k">def</span> <span class="nf">_get_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_freq</span><span class="p">,</span> <span class="n">_set_freq</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;array of frequencies in Hz&#39;</span><span class="p">)</span>

    <span class="c1"># ----impedance tensor ---------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the attribute &#39;z&#39;.</span>

<span class="sd">        Arguments</span>
<span class="sd">                -------------</span>

<span class="sd">            **z_array** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                        complex impedance tensor array</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        Nulling the rotation_angle</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">z_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">z_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="n">z_array</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">z_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">z_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_array</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;provided Z array does not have correct dimensions&#39;</span>
                       <span class="s1">&#39;- Z unchanged&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">,</span>
                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_z</span><span class="p">))</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Need to input frequency array&#39;</span>

    <span class="k">def</span> <span class="nf">_get_z</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span>

    <span class="n">z</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_z</span><span class="p">,</span> <span class="n">_set_z</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;impedance tensor&quot;</span><span class="p">)</span>

    <span class="c1"># ----impedance error-----------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_z_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_err_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the attribute z_err</span>

<span class="sd">        Arguments</span>
<span class="sd">                ------------</span>

<span class="sd">            **z_err_array** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                           error of impedance tensor array as standard deviation</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z_err_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;z_err_array shape </span><span class="si">{0}</span><span class="s1"> is not same shape as z </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">z_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span> <span class="o">=</span> <span class="n">z_err_array</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Need to input frequency array&#39;</span>

    <span class="k">def</span> <span class="nf">_get_z_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_err</span>

    <span class="n">z_err</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_z_err</span><span class="p">,</span> <span class="n">_set_z_err</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;impedance tensor error&#39;</span><span class="p">)</span>

    <span class="c1"># ---real part of impedance tensor-----------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the real part of Z.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;z array is None - cannot calculate real&#39;</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the real part of &#39;z&#39;.</span>

<span class="sd">        Arguments</span>
<span class="sd">                -------------</span>

<span class="sd">            **real_array** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                          real part of impedance tensor array</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">real_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;shape of &quot;real&quot; array does not match shape of&#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;Z array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">real_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">real_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;real&quot; is not real valued !&#39;</span>
            <span class="k">return</span>

        <span class="n">ii_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="n">real_array</span> <span class="o">+</span> <span class="n">ii_arr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="n">real_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z_new</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>

    <span class="c1"># real = property(_get_real, _set_real, doc=&#39;Real part of Z&#39;)</span>
    <span class="c1"># ---imaginary part of impedance tensor------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the imaginary part of Z.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;z array is None - cannot calculate imag&#39;</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imag_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the imaginary part of &#39;z&#39;.</span>

<span class="sd">        Arguments</span>
<span class="sd">                -------------</span>

<span class="sd">            **imag_array** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                           imaginary part of impedance tensor array</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">imag_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;imag&quot; array does not match shape of&#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;Z array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">imag_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">imag_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;imag&quot; is not real valued !&#39;</span>
            <span class="k">return</span>

        <span class="n">i_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="o">+</span> <span class="n">i_arr</span> <span class="o">*</span> <span class="n">imag_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="n">i_arr</span> <span class="o">*</span> <span class="n">imag_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z_new</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span>

    <span class="c1"># imag = property(_get_imag, _set_imag, doc=&#39;Imaginary part of Z &#39;)</span>

    <span class="c1"># -----resistivity and phase----------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_compute_res_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets attributes</span>
<span class="sd">                        * resistivity</span>
<span class="sd">                        * phase</span>
<span class="sd">                        * resistivity_err</span>
<span class="sd">                        * phase_err</span>

<span class="sd">        values for resistivity are in in Ohm-m and phase in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Need to input frequency list&#39;</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Z array is None - cannot calculate Res/Phase&#39;</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

        <span class="c1"># calculate resistivity and phase</span>
        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">cmath</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">r_err</span><span class="p">,</span> <span class="n">phi_err</span> <span class="o">=</span> <span class="n">MTcc</span><span class="o">.</span><span class="n">z_error2r_phi_error</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="mf">0.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span> <span class="o">/</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span> <span class="o">*</span> <span class="n">r_err</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_err</span>

    <span class="k">def</span> <span class="nf">_get_resistivity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity</span>

    <span class="k">def</span> <span class="nf">_get_resistivity_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resistivity_err</span>

    <span class="k">def</span> <span class="nf">_get_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span>

    <span class="k">def</span> <span class="nf">_get_phase_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span>

    <span class="k">def</span> <span class="nf">_set_resistivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;cannot be set individually - use method &#39;set_res_phase&#39;!&quot;</span>

    <span class="k">def</span> <span class="nf">_set_resistivity_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;cannot be set individually - use method &#39;set_res_phase&#39;!&quot;</span>

    <span class="k">def</span> <span class="nf">_set_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;cannot be set individually - use method &#39;set_res_phase&#39;!&quot;</span>

    <span class="k">def</span> <span class="nf">_set_phase_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;cannot be set individually - use method &#39;set_res_phase&#39;!&quot;</span>

    <span class="n">resistivity</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_resistivity</span><span class="p">,</span>
                           <span class="n">_set_resistivity</span><span class="p">,</span>
                           <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Resistivity array&#39;</span><span class="p">)</span>
    <span class="n">resistivity_err</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_resistivity_err</span><span class="p">,</span>
                               <span class="n">_set_resistivity_err</span><span class="p">,</span>
                               <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Resistivity error array&#39;</span><span class="p">)</span>

    <span class="n">phase</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_phase</span><span class="p">,</span>
                     <span class="n">_set_phase</span><span class="p">,</span>
                     <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Phase array&#39;</span><span class="p">)</span>
    <span class="n">phase_err</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_phase_err</span><span class="p">,</span>
                         <span class="n">_set_phase_err</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Phase error array&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Z.set_res_phase"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Z.set_res_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_res_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res_array</span><span class="p">,</span> <span class="n">phase_array</span><span class="p">,</span> <span class="n">reserr_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">phaseerr_array</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set values for resistivity (res - in Ohm m) and phase</span>
<span class="sd">        (phase - in degrees), including error propagation.</span>

<span class="sd">        Updates the attributes</span>
<span class="sd">                        * z</span>
<span class="sd">                        * z_err</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">res_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;res&quot; array does not match shape&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;of Z array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phase_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phase&quot; array does not match shape&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;of Z array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">res_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">res_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phase_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phase&quot; array does not match shape&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;of &quot;res&quot; array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                                         <span class="n">res_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res_array</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_EDI</span><span class="p">(</span><span class="s1">&#39;ERROR - cannot set res without correct&#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;freq information - proper &quot;freq&quot; &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;attribute must be defined&#39;</span><span class="p">)</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">res_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Error - array &quot;res&quot; is not&#39;</span> <span class="o">+</span>
                                                <span class="s1">&#39;real valued !&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">phase_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_inputarguments</span><span class="p">(</span><span class="s1">&#39;Error - array &quot;phase&quot; is&#39;</span> <span class="o">+</span>
                                                <span class="s1">&#39;not real valued !&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_new</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">abs_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span> <span class="o">*</span>
                                    <span class="n">res_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>
                    <span class="n">z_new</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">abs_z</span><span class="p">,</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phase_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z_new</span>

        <span class="c1"># ---------------------------</span>
        <span class="c1"># error propagation:</span>
        <span class="k">if</span> <span class="n">reserr_array</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">phaseerr_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z_err_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">reserr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;reserr&quot; array does not match&#39;</span> <span class="o">+</span> \
                          <span class="s1">&#39;shape of Zerr array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                              <span class="n">reserr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">return</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phaseerr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phase&quot; array does not match&#39;</span> <span class="o">+</span> \
                          <span class="s1">&#39;shape of Zerr array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                              <span class="n">phase_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - &quot;phaseerr&quot; or &quot;reserr&quot; is/are not array(s)&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;- Zerr not set&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">z_err_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">reserr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">reserr_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phaseerr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phase&quot; array does not match&#39;</span> <span class="o">+</span> \
                          <span class="s1">&#39;shape of Zerr array: </span><span class="si">{0}</span><span class="s1"> ; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                              <span class="n">reserr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - &quot;phaseerr&quot; or &quot;reserr&quot; is/are not array(s) -&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39; Zerr not set&#39;</span>
                <span class="k">return</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z_err_new</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">abs_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span> <span class="o">*</span>
                                    <span class="n">res_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>
                    <span class="n">rel_error_res</span> <span class="o">=</span> <span class="n">reserr_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">/</span> \
                        <span class="n">res_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                    <span class="c1"># relative error varies by a factor of 0.5, which is the</span>
                    <span class="c1"># exponent in the relation between them:</span>
                    <span class="n">abs_z_error</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">abs_z</span> <span class="o">*</span> <span class="n">rel_error_res</span>

                    <span class="n">z_err_new</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MTcc</span><span class="o">.</span><span class="n">propagate_error_polar2rect</span><span class="p">(</span>
                        <span class="n">abs_z</span><span class="p">,</span>
                        <span class="n">abs_z_error</span><span class="p">,</span>
                        <span class="n">phase_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                        <span class="n">phaseerr_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="o">=</span> <span class="n">z_err_new</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the inverse of Z.</span>

<span class="sd">            (no error propagtaion included yet)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;z array is &quot;None&quot; - I cannot invert that&#39;</span>
            <span class="k">return</span>

        <span class="n">inverse</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inverse</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inverse</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]))</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_Z</span><span class="p">(</span><span class="s1">&#39;The </span><span class="si">{0}</span><span class="s1">ith impedance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx_f</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="s1">&#39;tensor cannot be inverted&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inverse</span>

    <span class="n">inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_inverse</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Inverse of Z&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Z.rotate"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Z.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate Z array by angle alpha.</span>

<span class="sd">        Rotation angle must be given in degrees. All angles are referenced</span>
<span class="sd">        to geographic North, positive in clockwise direction.</span>
<span class="sd">        (Mathematically negative!)</span>

<span class="sd">        In non-rotated state, X refs to North and Y to East direction.</span>

<span class="sd">        Updates the attributes</span>
<span class="sd">            - *z*</span>
<span class="sd">            - *z_err*</span>
<span class="sd">            - *zrot*</span>
<span class="sd">            - *resistivity*</span>
<span class="sd">            - *phase*</span>
<span class="sd">            - *resistivity_err*</span>
<span class="sd">            - *phase_err*</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Z array is &quot;None&quot; - I cannot rotate that&#39;</span>
            <span class="k">return</span>

        <span class="c1"># check for iterable list/set of angles - if so, it must have length</span>
        <span class="c1"># 1 or same as len(tipper):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">degreeangle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;&quot;Angle&quot; must be a valid number (in degrees)&#39;</span>
                <span class="k">return</span>

            <span class="c1"># make an n long list of identical angles</span>
            <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">degreeangle</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">degreeangle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;Angle&quot; must be a valid number (in degrees)&#39;</span>
                    <span class="k">return</span>
                <span class="c1"># make an n long list of identical angles</span>
                <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">degreeangle</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ii</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;Angles&quot; must be valid numbers (in degrees)&#39;</span>
                    <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">oldangle</span> <span class="o">+</span> <span class="n">lo_angles</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">%</span> <span class="mi">360</span>
                                        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">oldangle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">)])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_angles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Wrong number of &quot;angles&quot; - I need </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="c1"># self.rotation_angle = 0.</span>
            <span class="k">return</span>

        <span class="n">z_rot</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_err_rot</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)):</span>

            <span class="n">angle</span> <span class="o">=</span> <span class="n">lo_angles</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">z_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">],</span> <span class="n">z_err_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">MTcc</span><span class="o">.</span><span class="n">rotatematrix_incl_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                                  <span class="n">angle</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">z_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">],</span> <span class="n">z_err_rot</span> <span class="o">=</span> \
                    <span class="n">MTcc</span><span class="o">.</span><span class="n">rotatematrix_incl_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                                  <span class="n">angle</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z_rot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="o">=</span> <span class="n">z_err_rot</span>

        <span class="c1"># for consistency recalculate resistivity and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_res_phase</span><span class="p">()</span></div>

<div class="viewcode-block" id="Z.remove_ss"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Z.remove_ss">[docs]</a>    <span class="k">def</span> <span class="nf">remove_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduce_res_factor_x</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">reduce_res_factor_y</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the static shift by providing the respective correction factors</span>
<span class="sd">        for the resistivity in the x and y components.</span>
<span class="sd">        (Factors can be determined by using the &quot;Analysis&quot; module for the</span>
<span class="sd">        impedance tensor)</span>

<span class="sd">        Assume the original observed tensor Z is built by a static shift S</span>
<span class="sd">        and an unperturbated &quot;correct&quot; Z0 :</span>

<span class="sd">             * Z = S * Z0</span>

<span class="sd">        therefore the correct Z will be :</span>
<span class="sd">            * Z0 = S^(-1) * Z</span>

<span class="sd">        Arguments</span>
<span class="sd">        ------------</span>

<span class="sd">            **reduce_res_factor_x** : float or iterable list or array</span>
<span class="sd">                                    static shift factor to be applied to x</span>
<span class="sd">                                    components (ie z[:, 0, 1]).  This is</span>
<span class="sd">                                    assumed to be in resistivity scale</span>

<span class="sd">            **reduce_res_factor_y** : float or iterable list or array</span>
<span class="sd">                                    static shift factor to be applied to y</span>
<span class="sd">                                    components (ie z[:, 1, 0]).  This is</span>
<span class="sd">                                    assumed to be in resistivity scale</span>

<span class="sd">        Returns</span>
<span class="sd">                --------------</span>

<span class="sd">            **S** : np.ndarray ((2, 2))</span>
<span class="sd">                    static shift matrix,</span>

<span class="sd">            **Z0**: corrected Z   (over all freq)</span>

<span class="sd">        .. note:: The factors are in resistivity scale, so the</span>
<span class="sd">                  entries of  the matrix &quot;S&quot; need to be given by their</span>
<span class="sd">                  square-roots!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check for iterable list/set of reduce_res_factor_x - if so, it must</span>
        <span class="c1"># have length 1 or same as len(z):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">reduce_res_factor_x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reduce_res_factor_x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_x&quot; must be a valid numbers&#39;</span>
                <span class="k">return</span>

            <span class="n">lo_x_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x_factor</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_res_factor_x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">x_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reduce_res_factor_x</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_x&quot; must be a valid numbers&#39;</span>
                    <span class="k">return</span>
                <span class="n">lo_x_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x_factor</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lo_x_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x_factor</span><span class="p">,</span>
                                             <span class="nb">len</span><span class="p">(</span><span class="n">reduce_res_factor_x</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_x&quot; must be valid numbers&#39;</span>
                    <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_x_factors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Wrong number Number of &quot;reduce_res_factor_x&quot;&#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;- need </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># check for iterable list/set of reduce_res_factor_y - if so,</span>
        <span class="c1"># it must have length 1 or same as len(z):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">reduce_res_factor_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">y_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reduce_res_factor_y</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_y&quot; must be a valid numbers&#39;</span>
                <span class="k">return</span>

            <span class="n">lo_y_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y_factor</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduce_res_factor_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">y_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">reduce_res_factor_y</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_y&quot; must be a valid numbers&#39;</span>
                    <span class="k">return</span>
                <span class="n">lo_y_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y_factor</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lo_y_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y_factor</span><span class="p">,</span>
                                             <span class="nb">len</span><span class="p">(</span><span class="n">reduce_res_factor_y</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;reduce_res_factor_y&quot; must be valid numbers&#39;</span>
                    <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_y_factors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Wrong number Number of &quot;reduce_res_factor_y&quot;&#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;- need </span><span class="si">{0}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="n">z_corrected</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">static_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)):</span>
            <span class="c1"># correct for x-direction</span>
            <span class="n">z_corrected</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lo_x_factors</span><span class="p">[</span><span class="n">idx_f</span><span class="p">])</span>
            <span class="c1"># correct for y-direction</span>
            <span class="n">z_corrected</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lo_y_factors</span><span class="p">[</span><span class="n">idx_f</span><span class="p">])</span>
            <span class="c1"># make static shift array</span>
            <span class="n">static_shift</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lo_x_factors</span><span class="p">[</span><span class="n">idx_f</span><span class="p">])</span>
            <span class="n">static_shift</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lo_y_factors</span><span class="p">[</span><span class="n">idx_f</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">static_shift</span><span class="p">,</span> <span class="n">z_corrected</span></div>

<div class="viewcode-block" id="Z.remove_distortion"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Z.remove_distortion">[docs]</a>    <span class="k">def</span> <span class="nf">remove_distortion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distortion_tensor</span><span class="p">,</span> <span class="n">distortion_err_tensor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove distortion D form an observed impedance tensor Z to obtain</span>
<span class="sd">        the uperturbed &quot;correct&quot; Z0:</span>
<span class="sd">        Z = D * Z0</span>

<span class="sd">        Propagation of errors/uncertainties included</span>

<span class="sd">                Arguments</span>
<span class="sd">                ------------</span>
<span class="sd">                        **distortion_tensor** : np.ndarray(2, 2, dtype=real)</span>
<span class="sd">                                              real distortion tensor as a 2x2</span>

<span class="sd">                        **distortion_err_tensor** : np.ndarray(2, 2, dtype=real),</span>
<span class="sd">                                                                          default is None</span>

<span class="sd">                Returns</span>
<span class="sd">                -----------</span>
<span class="sd">                        **distortion_tensor** :  np.ndarray(2, 2, dtype=&#39;real&#39;)</span>
<span class="sd">                                               input distortion tensor</span>
<span class="sd">                        **z_corrected** : np.ndarray(num_freq, 2, 2, dtype=&#39;complex&#39;)</span>
<span class="sd">                                        impedance tensor with distorion removed</span>

<span class="sd">                        **z_corrected_err** : np.ndarray(num_freq, 2, 2, dtype=&#39;complex&#39;)</span>
<span class="sd">                                                            impedance tensor error after distortion is removed</span>

<span class="sd">                Example</span>
<span class="sd">                ----------</span>
<span class="sd">                        &gt;&gt;&gt; import mtpy.core.z as mtz</span>
<span class="sd">                        &gt;&gt;&gt; distortion = np.array([[1.2, .5],[.35, 2.1]])</span>
<span class="sd">                        &gt;&gt;&gt; d, new_z, new_z_err = z_obj.remove_distortion(distortion)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">distortion_err_tensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">distortion_err_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distortion_tensor</span><span class="p">)</span>
        <span class="c1"># for all freq, calculate D.Inverse, then obtain Z0 = D.I * Z</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distortion_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distortion_err_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape not the same&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distortion_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="n">distortion_err_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Distortion is not time-dependent - take only first&#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;of given distortion tensors&#39;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">distortion_tensor</span> <span class="o">=</span> <span class="n">distortion_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">distortion_err_tensor</span> <span class="o">=</span> <span class="n">distortion_err_tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;distortion tensor the wrong shape&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">distortion_tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="n">distortion_err_tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape not the same&#39;</span><span class="p">)</span>

            <span class="n">distortion_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">distortion_tensor</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_Z</span><span class="p">(</span><span class="s1">&#39;The array provided is not a proper&#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;distortion tensor&#39;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">DI</span> <span class="o">=</span> <span class="n">distortion_tensor</span><span class="o">.</span><span class="n">I</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_Z</span><span class="p">(</span><span class="s1">&#39;The provided distortion tensor is&#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;singular - I cannot invert that!&#39;</span><span class="p">)</span>

        <span class="c1"># propagation of errors (using 1-norm) - step 1 - inversion of D:</span>
        <span class="n">DI_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">distortion_err_tensor</span><span class="p">)</span>

        <span class="c1"># todo :include error on  determinant!!</span>
        <span class="c1"># D_det = np.linalg.det(distortion_tensor)</span>

        <span class="n">dummy</span><span class="p">,</span> <span class="n">DI_err</span> <span class="o">=</span> <span class="n">MTcc</span><span class="o">.</span><span class="n">invertmatrix_incl_errors</span><span class="p">(</span><span class="n">distortion_tensor</span><span class="p">,</span>
                                                      <span class="n">distortion_err_tensor</span><span class="p">)</span>

        <span class="c1"># propagation of errors - step 2 - product of D.inverse and Z;</span>
        <span class="c1"># D.I * Z, making it 4 summands for each component:</span>
        <span class="n">z_corrected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">z_corrected_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)):</span>
            <span class="n">z_corrected</span><span class="p">[</span><span class="n">idx_f</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">DI</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">])))</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">z_corrected_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">DI_err</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                                  <span class="n">DI</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                                  <span class="n">DI_err</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                                  <span class="n">DI</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">]])))</span>

        <span class="k">return</span> <span class="n">distortion_tensor</span><span class="p">,</span> <span class="n">z_corrected</span><span class="p">,</span> <span class="n">z_corrected_err</span></div>

    <span class="k">def</span> <span class="nf">_get_only1d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Z in 1D form.</span>

<span class="sd">        If Z is not 1D per se, the diagonal elements are set to zero,</span>
<span class="sd">        the off-diagonal elements keep their signs, but their absolute</span>
<span class="sd">        is set to the mean of the original Z off-diagonal absolutes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">z1d</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z1d</span><span class="p">)):</span>
            <span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sign01</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">sign10</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">mean1d</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sign01</span> <span class="o">*</span> <span class="n">mean1d</span>
            <span class="n">z1d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sign10</span> <span class="o">*</span> <span class="n">mean1d</span>

        <span class="k">return</span> <span class="n">z1d</span>

    <span class="n">only1d</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_only1d</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot; Return Z in 1D form. If Z is not 1D per se,</span>
<span class="s2">                              the diagonal elements are set to zero, the</span>
<span class="s2">                              off-diagonal elements keep their signs, but</span>
<span class="s2">                              their absolute is set to the mean of the</span>
<span class="s2">                              original Z off-diagonal absolutes.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_only2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Z in 2D form.</span>

<span class="sd">        If Z is not 2D per se, the diagonal elements are set to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">z2d</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z2d</span><span class="p">)):</span>
            <span class="n">z2d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">z2d</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">z2d</span>

    <span class="n">only2d</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_only2d</span><span class="p">,</span>
                      <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Return Z in 2D form. If Z is not 2D per se,</span>
<span class="s2">                             the diagonal elements are set to zero. &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the trace of Z (incl. uncertainties).</span>

<span class="sd">        Returns</span>
<span class="sd">            -------------</span>
<span class="sd">            **tr** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                    Trace(z)</span>
<span class="sd">            **tr_err** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                       Error of Trace(z)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

        <span class="n">tr_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tr_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="n">tr_err</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tr_err</span>

    <span class="n">trace</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_trace</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Trace of Z, incl. error&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_skew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the skew of Z (incl. uncertainties).</span>

<span class="sd">        Returns</span>
<span class="sd">            -----------</span>
<span class="sd">            **skew**: np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                    skew(z)</span>
<span class="sd">            **skew_err** : np.ndarray(nfreq, 2, 2)</span>
<span class="sd">                         Error of skew(z)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">skew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ii</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ii</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

        <span class="n">skewerr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skewerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">skew</span><span class="p">)</span>
            <span class="n">skewerr</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">skew</span><span class="p">,</span> <span class="n">skewerr</span>

    <span class="n">skew</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_skew</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Skew of Z, incl. error&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the determinant of Z (incl. uncertainties).</span>

<span class="sd">        Returns</span>
<span class="sd">                ----------</span>
<span class="sd">            **det_Z** : np.ndarray(nfreq)</span>
<span class="sd">                      det(z)</span>
<span class="sd">            **det_Z_err** : np.ndarray(nfreq)</span>
<span class="sd">                          Error of det(z)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">det_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>

        <span class="n">det_Z_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_Z_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">det_Z</span><span class="p">)</span>
            <span class="n">det_Z_err</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">det_Z</span><span class="p">,</span> <span class="n">det_Z_err</span>

    <span class="n">det</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_det</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Determinant of Z, incl. error&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the 2-/Frobenius-norm of Z (NO uncertainties yet).</span>

<span class="sd">        Returns</span>
<span class="sd">                ---------</span>
<span class="sd">            **znorm** : np.ndarray(nfreq)</span>
<span class="sd">                      norm(z)</span>
<span class="sd">            **znormerr** : np.ndarray(nfreq)</span>
<span class="sd">                         Error of norm(z)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">znorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
        <span class="n">znormerr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">znormerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">znorm</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">z_tmp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">znorm</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">error_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_err</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">radicand</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">radicand</span> <span class="o">+=</span> <span class="p">(</span><span class="n">error_matrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">*</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z_tmp</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>
                        <span class="n">radicand</span> <span class="o">+=</span> <span class="p">(</span><span class="n">error_matrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">*</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z_tmp</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span> <span class="o">**</span> <span class="mi">2</span>

                <span class="n">znormerr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radicand</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">znorm</span><span class="p">,</span> <span class="n">znormerr</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_norm</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Norm of Z, incl. error&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_invariants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of Z-invariants.</span>

<span class="sd">        Contains</span>
<span class="sd">                -----------</span>
<span class="sd">                        * z1</span>
<span class="sd">                        * det</span>
<span class="sd">                        * det_real</span>
<span class="sd">                        * det_imag</span>
<span class="sd">                        * trace</span>
<span class="sd">                        * skew</span>
<span class="sd">                        * norm</span>
<span class="sd">                        * lambda_plus/minus,</span>
<span class="sd">                        * sigma_plus/minus</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">invariants_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">z1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;z1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span>

        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;det&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">det_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)])</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;det_real&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_real</span>

        <span class="n">det_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z</span><span class="p">)])</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;det_imag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_imag</span>

        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;trace&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;skew&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">lambda_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z1</span><span class="p">))])</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;lambda_plus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_plus</span>

        <span class="n">lambda_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">z1</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">-</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z1</span><span class="p">))])</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;lambda_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lambda_minus</span>

        <span class="n">sigma_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>

        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;sigma_plus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_plus</span>

        <span class="n">sigma_minus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">]</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ii</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>
        <span class="n">invariants_dict</span><span class="p">[</span><span class="s1">&#39;sigma_minus&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_minus</span>

        <span class="k">return</span> <span class="n">invariants_dict</span>

    <span class="n">invariants</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_invariants</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Dictionary, containing the invariants of</span>
<span class="s2">                                 Z: z1, det, det_real, det_imag, trace,</span>
<span class="s2">                                 skew, norm, lambda_plus/minus,</span>
<span class="s2">                                 sigma_plus/minus&quot;&quot;&quot;</span><span class="p">)</span></div>


<span class="c1"># ======================================================================</span>
<span class="c1">#                               TIPPER</span>
<span class="c1"># ======================================================================</span>

<div class="viewcode-block" id="Tipper"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Tipper">[docs]</a><span class="k">class</span> <span class="nc">Tipper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tipper class --&gt; generates a Tipper-object.</span>

<span class="sd">    Errors are given as standard deviations (sqrt(VAR))</span>

<span class="sd">    Arguments</span>
<span class="sd">        -----------</span>

<span class="sd">        **tipper_array** : np.ndarray((nf, 1, 2), dtype=&#39;complex&#39;)</span>
<span class="sd">                          tipper array in the shape of [Tx, Ty]</span>
<span class="sd">                          *default* is None</span>

<span class="sd">        **tipper_err_array** : np.ndarray((nf, 1, 2))</span>
<span class="sd">                             array of estimated tipper errors</span>
<span class="sd">                               in the shape of [Tx, Ty].</span>
<span class="sd">                               Must be the same shape as tipper_array.</span>
<span class="sd">                               *default* is None</span>

<span class="sd">        **freq** : np.ndarray(nf)</span>
<span class="sd">                   array of frequencies corresponding to the tipper elements.</span>
<span class="sd">                   Must be same length as tipper_array.</span>
<span class="sd">                   *default* is None</span>

<span class="sd">    =============== ===========================================================</span>
<span class="sd">    Attributes      Description</span>
<span class="sd">    =============== ===========================================================</span>
<span class="sd">    freq            array of frequencies corresponding to elements of z</span>
<span class="sd">    rotation_angle  angle of which data is rotated by</span>

<span class="sd">    tipper          tipper array</span>
<span class="sd">    tipper_err       tipper error array</span>
<span class="sd">    =============== ===========================================================</span>

<span class="sd">    =============== ===========================================================</span>
<span class="sd">    Methods         Description</span>
<span class="sd">    =============== ===========================================================</span>
<span class="sd">    mag_direction   computes magnitude and direction of real and imaginary</span>
<span class="sd">                    induction arrows.</span>
<span class="sd">    amp_phase       computes amplitude and phase of Tx and Ty.</span>
<span class="sd">    rotate          rotates the data by the given angle</span>
<span class="sd">    =============== ===========================================================</span>



<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tipper_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tipper_err_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialise an instance of the Tipper class.</span>

<span class="sd">        Arguments</span>
<span class="sd">                --------------</span>

<span class="sd">            **tipper_array** : np.ndarray((nf, 1, 2), dtype=&#39;complex&#39;)</span>
<span class="sd">                               tipper array in the shape of [Tx, Ty]</span>
<span class="sd">                               *default* is None</span>

<span class="sd">            **tipper_err_array** : np.ndarray((nf, 1, 2))</span>
<span class="sd">                                   array of estimated tipper errors</span>
<span class="sd">                                   in the shape of [Tx, Ty].</span>
<span class="sd">                                   Must be the same shape as tipper_array.</span>
<span class="sd">                                   *default* is None</span>

<span class="sd">            **freq** : np.ndarray(nf)</span>
<span class="sd">                       array of frequencies corresponding to the tipper</span>
<span class="sd">                       elements.</span>
<span class="sd">                       Must be same length as tipper_array.</span>
<span class="sd">                       *default* is None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span> <span class="o">=</span> <span class="n">tipper_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span> <span class="o">=</span> <span class="n">tipper_err_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mag_real</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mag_imag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_real</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_imag</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mag_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_err</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># ==========================================================================</span>
    <span class="c1"># Define get/set and properties</span>
    <span class="c1"># ==========================================================================</span>
    <span class="c1"># ----freq----------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lo_freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the array of freq.</span>

<span class="sd">        Arguments</span>
<span class="sd">                -----------</span>

<span class="sd">            **lo_freq** : list or array of frequnecies (Hz)</span>

<span class="sd">        No test for consistency!</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;length of freq list/array not correct&#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39; (</span><span class="si">%i</span><span class="s1">i instead of </span><span class="si">%i</span><span class="s1">i)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lo_freq</span><span class="p">)</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="n">freq</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_freq</span><span class="p">,</span> <span class="n">_set_freq</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;array of freq&#39;</span><span class="p">)</span>

    <span class="c1"># ---tipper--------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_tipper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tipper_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the attribute *tipper*</span>

<span class="sd">        Arguments</span>
<span class="sd">                -------------</span>

<span class="sd">            **tipper_array** : np.ndarray((nf, 1, 2), dtype=&#39;complex&#39;)</span>
<span class="sd">                               tipper array in the shape of [Tx, Ty]</span>
<span class="sd">                               *default* is None</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the array is of required shape</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tipper_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">tipper_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                    <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tipper_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span> <span class="o">=</span> <span class="n">tipper_array</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># check to see if the new tipper array is the same shape as the old</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tipper_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;tipper&quot; array does not match shape of &#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;tipper-array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tipper_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                             <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span> <span class="o">=</span> <span class="n">tipper_array</span>

        <span class="c1"># neeed to set the rotation angle such that it is an array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">,</span>
                                            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span><span class="p">))</span>

            <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_tipper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tipper</span>

    <span class="n">tipper</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_tipper</span><span class="p">,</span> <span class="n">_set_tipper</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Tipper array&quot;</span><span class="p">)</span>

    <span class="c1"># ----tipper error---------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_set_tipper_err</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tipper_err_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the attribute *tipper_err*.</span>

<span class="sd">        Arguments</span>
<span class="sd">                --------------</span>
<span class="sd">            **tipper_err_array** : np.ndarray((nf, 1, 2))</span>
<span class="sd">                                   array of estimated tipper errors</span>
<span class="sd">                                   in the shape of [Tx, Ty].</span>
<span class="sd">                                   Must be the same shape as tipper_array.</span>
<span class="sd">                                   *default* is None</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure the input array is of required shape</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tipper_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> \
                    <span class="n">tipper_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tipper_err_array</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span> <span class="o">=</span> <span class="n">tipper_err_array</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># make sure the error array is the same shape as tipper</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tipper_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;tipper_err&quot; array does not match shape &#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;of tipper_err array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tipper_err_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span> <span class="o">=</span> <span class="n">tipper_err_array</span>

        <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_tipper_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tipper_err</span>

    <span class="n">tipper_err</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_tipper_err</span><span class="p">,</span> <span class="n">_set_tipper_err</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Estimated Tipper errors&quot;</span><span class="p">)</span>

    <span class="c1"># ----real part---------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the real part of the Tipper.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;tipper array is None - cannot calculate real&#39;</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the real part of &#39;tipper&#39;.</span>

<span class="sd">        Arguments</span>
<span class="sd">                --------------</span>

<span class="sd">            **tipper_array** : np.ndarray((nf, 1, 2)) real part</span>
<span class="sd">                               tipper array in the shape of [Tx, Ty]</span>
<span class="sd">                               *default* is None</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">real_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;shape of &quot;real&quot; array does not match shape of tipper &#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">real_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">real_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;real&quot; is not real valued !&#39;</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tipper_new</span> <span class="o">=</span> <span class="n">real_array</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tipper_new</span> <span class="o">=</span> <span class="n">real_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="o">=</span> <span class="n">tipper_new</span>

        <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span>

    <span class="n">_real</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_real</span><span class="p">,</span> <span class="n">_set_real</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Real part of the Tipper&#39;</span><span class="p">)</span>

    <span class="c1"># ---imaginary part------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the imaginary part of the Tipper.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;tipper array is None - cannot calculate imag&#39;</span>
            <span class="k">return</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imag_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the imaginary part of &#39;tipper&#39;.</span>

<span class="sd">        Arguments</span>
<span class="sd">                --------------</span>

<span class="sd">            **tipper_array** : np.ndarray((nf, 1, 2)) imaginary part</span>
<span class="sd">                               tipper array in the shape of [Tx, Ty]</span>
<span class="sd">                               *default* is None</span>

<span class="sd">        Test for shape, but no test for consistency!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">imag_array</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;shape of &quot;real&quot; array does not match shape of tipper &#39;</span> <span class="o">+</span> \
                  <span class="s1">&#39;array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">imag_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">imag_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;imag&quot; is not real valued !&#39;</span>
            <span class="k">return</span>

        <span class="n">ii_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tipper_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="o">+</span> <span class="n">ii_arr</span> <span class="o">*</span> <span class="n">imag_array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tipper_new</span> <span class="o">=</span> <span class="n">ii_arr</span> <span class="o">*</span> <span class="n">imag_array</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="o">=</span> <span class="n">tipper_new</span>

        <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span>

    <span class="n">_imag</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_imag</span><span class="p">,</span> <span class="n">_set_imag</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s1">&#39;Imaginary part of the Tipper&#39;</span><span class="p">)</span>

    <span class="c1"># ----amplitude and phase</span>
    <span class="k">def</span> <span class="nf">_compute_amp_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets attributes</span>
<span class="sd">                        * *amplitude*</span>
<span class="sd">                        * *phase*</span>
<span class="sd">                        * *amplitude_err*</span>
<span class="sd">                        * *phase_err*</span>

<span class="sd">        values for resistivity are in in Ohm m and phase in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># print &#39;tipper array is None - cannot calculate rho/phi&#39;</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phase</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">cmath</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">r_err</span><span class="p">,</span> <span class="n">phi_err</span> <span class="o">=</span> <span class="n">MTcc</span><span class="o">.</span><span class="n">propagate_error_rect2polar</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">amplitude_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_err</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phase_err</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_err</span>

<div class="viewcode-block" id="Tipper.set_amp_phase"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Tipper.set_amp_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_amp_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_array</span><span class="p">,</span> <span class="n">phi_array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set values for amplitude(r) and argument (phi - in degrees).</span>

<span class="sd">        Updates the attributes</span>
<span class="sd">                        * tipper</span>
<span class="sd">                        * tipper_err</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">tipper_new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">r_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;r&quot; array does not match shape of &#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;tipper array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phi_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phi&quot; array does not match shape of &#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;tipper array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">phi_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">tipper_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">r_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">r_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">phi_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;Error - shape of &quot;phi&quot; array does not match shape &#39;</span> <span class="o">+</span> \
                      <span class="s1">&#39;of &quot;r&quot; array: </span><span class="si">%s</span><span class="s1"> ; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">phi_array</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                                 <span class="nb">str</span><span class="p">(</span><span class="n">r_array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="k">return</span>

        <span class="c1"># assert real array:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">r_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;r&quot; is not real valued !&#39;</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">phi_array</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Error - array &quot;phi&quot; is not real valued !&#39;</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">idx_f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r_array</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">tipper_new</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">r_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">],</span>
                                                      <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">phi_array</span><span class="p">[</span><span class="n">idx_f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">jj</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="o">=</span> <span class="n">tipper_new</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span></div>

    <span class="c1"># ----magnitude and direction----------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_compute_mag_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes the magnitude and direction of the real and imaginary</span>
<span class="sd">        induction vectors.</span>

<span class="sd">        Returns</span>
<span class="sd">                ------------</span>

<span class="sd">            **mag_real** : np.array(nf)</span>
<span class="sd">                           magnitude of the real induction vector</span>

<span class="sd">            **ang_real** : np.array(nf)</span>
<span class="sd">                           angle (deg) of the real induction vector assuming</span>
<span class="sd">                           that North is 0 and angle is positive clockwise</span>

<span class="sd">            **mag_imag** : np.array(nf)</span>
<span class="sd">                           magnitude of the imaginary induction vector</span>

<span class="sd">            **ang_imag** : np.array(nf)</span>
<span class="sd">                           angle (deg) of the imaginary induction vector</span>
<span class="sd">                           assuming that North is 0 and angle is positive</span>
<span class="sd">                           clockwise</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mag_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mag_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mag_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># get the angle, need to make both parts negative to get it into the</span>
        <span class="c1"># parkinson convention where the arrows point towards the conductor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">angle_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">angle_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span>
                                                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>

        <span class="c1"># estimate error: THIS MAYBE A HACK</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mag_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">%</span> <span class="mi">45</span>

<div class="viewcode-block" id="Tipper.set_mag_direction"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Tipper.set_mag_direction">[docs]</a>    <span class="k">def</span> <span class="nf">set_mag_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mag_real</span><span class="p">,</span> <span class="n">ang_real</span><span class="p">,</span> <span class="n">mag_imag</span><span class="p">,</span> <span class="n">ang_imag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes the tipper from the magnitude and direction of the real</span>
<span class="sd">        and imaginary components.</span>

<span class="sd">        Updates tipper</span>

<span class="sd">        No error propagation yet</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">mag_real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_real</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_real</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mag_real</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span>
                                            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_real</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">mag_imag</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_imag</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                                            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_imag</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mag_imag</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span>
                                            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">ang_imag</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span></div>

    <span class="c1"># ----rotate---------------------------------------------------------------</span>
<div class="viewcode-block" id="Tipper.rotate"><a class="viewcode-back" href="../../../core.html#mtpy.core.z.Tipper.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate  Tipper array.</span>

<span class="sd">        Rotation angle must be given in degrees. All angles are referenced</span>
<span class="sd">        to geographic North=0, positive in clockwise direction.</span>
<span class="sd">        (Mathematically negative!)</span>

<span class="sd">        In non-rotated state, &#39;X&#39; refs to North and &#39;Y&#39; to East direction.</span>

<span class="sd">        Updates the attributes</span>
<span class="sd">                        * *tipper*</span>
<span class="sd">                        * *tipper_err*</span>
<span class="sd">                        * *rotation_angle*</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;tipper array is &quot;None&quot; - I cannot rotate that&#39;</span>
            <span class="k">return</span>

        <span class="c1"># check for iterable list/set of angles - if so, it must have length 1</span>
        <span class="c1"># or same as len(tipper):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">degreeangle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span> <span class="s1">&#39;&quot;Angle&quot; must be a valid number (in degrees)&#39;</span>
                <span class="k">return</span>

            <span class="c1"># make an n long list of identical angles</span>
            <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">degreeangle</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">degreeangle</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alpha</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;Angle&quot; must be a valid number (in degrees)&#39;</span>
                    <span class="k">return</span>
                <span class="c1"># make an n long list of identical angles</span>
                <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="n">degreeangle</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lo_angles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ii</span> <span class="o">%</span> <span class="mi">360</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="s1">&#39;&quot;Angles&quot; must be valid numbers (in degrees)&#39;</span>
                    <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">oldangle</span> <span class="o">+</span> <span class="n">lo_angles</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">%</span> <span class="mi">360</span>
                                        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">oldangle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">)])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lo_angles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s1">&#39;Wrong number Number of &quot;angles&quot; - need </span><span class="si">%i</span><span class="s1">i &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">return</span>

        <span class="n">tipper_rot</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">)</span>
        <span class="n">tipper_err_rot</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx_freq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tipper_rot</span><span class="p">)):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">lo_angles</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tipper_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">],</span> <span class="n">tipper_err_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">MTcc</span><span class="o">.</span><span class="n">rotatevector_incl_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                                  <span class="n">angle</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tipper_rot</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">],</span> <span class="n">tipper_err_rot</span> <span class="o">=</span> \
                    <span class="n">MTcc</span><span class="o">.</span><span class="n">rotatevector_incl_errors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tipper</span><span class="p">[</span><span class="n">idx_freq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                                  <span class="n">angle</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tipper</span> <span class="o">=</span> <span class="n">tipper_rot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tipper_err</span> <span class="o">=</span> <span class="n">tipper_err_rot</span>

        <span class="c1"># for consistency recalculate mag and angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mag_direction</span><span class="p">()</span>

        <span class="c1"># for consistency recalculate amplitude and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_amp_phase</span><span class="p">()</span></div></div>


<span class="c1"># ------------------------</span>
<span class="k">def</span> <span class="nf">correct4sensor_orientation</span><span class="p">(</span><span class="n">Z_prime</span><span class="p">,</span> <span class="n">Bx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">By</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">Ex</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ey</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span>
                               <span class="n">Z_prime_error</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct a Z-array for wrong orientation of the sensors.</span>

<span class="sd">    Assume, E&#39; is measured by sensors orientated with the angles</span>
<span class="sd">        E&#39;x: a</span>
<span class="sd">        E&#39;y: b</span>

<span class="sd">    Assume, B&#39; is measured by sensors orientated with the angles</span>
<span class="sd">        B&#39;x: c</span>
<span class="sd">        B&#39;y: d</span>

<span class="sd">    With those data, one obtained the impedance tensor Z&#39;:</span>
<span class="sd">        E&#39; = Z&#39; * B&#39;</span>

<span class="sd">    Now we define change-of-basis matrices T,U so that</span>
<span class="sd">        E = T * E&#39;</span>
<span class="sd">        B = U * B&#39;</span>

<span class="sd">    =&gt;   T contains the expression of the E&#39;-basis in terms of E</span>
<span class="sd">    (the standard basis)</span>
<span class="sd">    and  U contains the expression of the B&#39;-basis in terms of B</span>
<span class="sd">    (the standard basis)</span>
<span class="sd">    The respective expressions for E&#39;x-basis vector and E&#39;y-basis</span>
<span class="sd">    vector are the columns of T.</span>
<span class="sd">    The respective expressions for B&#39;x-basis vector and B&#39;y-basis</span>
<span class="sd">    vector are the columns of U.</span>

<span class="sd">    We obtain the impedance tensor in default coordinates as:</span>

<span class="sd">    E&#39; = Z&#39; * B&#39; =&gt; T^(-1) * E = Z&#39; * U^(-1) * B</span>
<span class="sd">                 =&gt; E = T * Z&#39; * U^(-1) * B</span>
<span class="sd">                 =&gt; Z = T * Z&#39; * U^(-1)</span>


<span class="sd">    Arguments</span>
<span class="sd">        ---------------</span>
<span class="sd">                **Z_prime** : np.ndarray(num_freq, 2, 2, dtype=&#39;complex&#39;)</span>
<span class="sd">                                          impedance tensor to be adjusted</span>

<span class="sd">                **Bx** : float (angle in degrees)</span>
<span class="sd">                         orientation of Bx relative to geographic north (0)</span>
<span class="sd">                                 *default* is 0</span>
<span class="sd">                **By** : float (angle in degrees)</span>
<span class="sd">                         orientation of By relative to geographic north (0)</span>
<span class="sd">                                 *default* is 90</span>
<span class="sd">                **Ex** : float (angle in degrees)</span>
<span class="sd">                         orientation of Ex relative to geographic north (0)</span>
<span class="sd">                                 *default* is 0</span>
<span class="sd">                **Ey** : float (angle in degrees)</span>
<span class="sd">                         orientation of Ey relative to geographic north (0)</span>
<span class="sd">                                 *default* is 90</span>

<span class="sd">                Z_prime_error : np.ndarray(Z_prime.shape)</span>
<span class="sd">                                impedance tensor error (std)</span>
<span class="sd">                                                *default* is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------------</span>
<span class="sd">                **Z** : np.ndarray(Z_prime.shape, dtype=&#39;complex&#39;)</span>
<span class="sd">                        adjusted impedance tensor</span>

<span class="sd">                **Z_err** : np.ndarray(Z_prime.shape, dtype=&#39;real&#39;)</span>
<span class="sd">                            impedance tensor standard deviation in</span>
<span class="sd">                                        default orientation</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_prime</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">Z_prime</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span>

        <span class="k">if</span> <span class="n">Z_prime</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
            <span class="k">raise</span>

        <span class="n">Z_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">Z_prime</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_inputarguments</span><span class="p">(</span><span class="s1">&#39;ERROR - Z array not valid!&#39;</span> <span class="o">+</span>
                                            <span class="s1">&#39;Must be 2x2 complex array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Z_prime_error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_prime_error</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">Z_prime_error</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span>

            <span class="k">if</span> <span class="n">Z_prime_error</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                <span class="k">raise</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_inputarguments</span><span class="p">(</span><span class="s1">&#39;ERROR - Z-error array not&#39;</span> <span class="o">+</span>
                                                <span class="s1">&#39;valid! Must be 2x2 real array&#39;</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="n">dummy1</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">Ex</span><span class="p">))</span>

    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dummy1</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dummy1</span><span class="p">)</span>
    <span class="n">dummy2</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">Ey</span><span class="p">))</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dummy2</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dummy2</span><span class="p">)</span>

    <span class="n">dummy3</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">Bx</span><span class="p">))</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dummy3</span><span class="p">)</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dummy3</span><span class="p">)</span>
    <span class="n">dummy4</span> <span class="o">=</span> <span class="n">cmath</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">By</span><span class="p">))</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dummy4</span><span class="p">)</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">dummy4</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">z_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z_prime</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">I</span><span class="p">)))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MTex</span><span class="o">.</span><span class="n">MTpyError_inputarguments</span><span class="p">(</span><span class="s2">&quot;ERROR - Given angles do not&quot;</span> <span class="o">+</span>
                                            <span class="s2">&quot;define basis for 2 dimensions - cannot convert Z&#39;&quot;</span><span class="p">)</span>

    <span class="n">z_err_arr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Z_prime_error</span><span class="p">)</span>

    <span class="c1"># TODO: calculate error propagation</span>

    <span class="k">return</span> <span class="n">z_arr</span><span class="p">,</span> <span class="n">z_err_arr</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../master_index.html">MTpy 0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, J. Peacock, L. Krieger.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>